{"ast":null,"code":"import CommandObject from \"./CommandObject\";\nexport default class DeleteCmdObj extends CommandObject {\n  constructor(undoHandler, newSelectedObj, selectedShapeId) {\n    super(undoHandler, true);\n    this.commandName = \"Delete \" + newSelectedObj.type;\n    console.log(this.commandName);\n\n    if (newSelectedObj !== null) {\n      this.targetObject = newSelectedObj; // global variable for selected\n\n      this.selectedShapeId = selectedShapeId;\n      this.isUndo = false;\n    } //selectedShapeId = newSelectedShapeId;\n\n\n    selectedObj = newSelectedObj;\n  }\n  /* override to execute the action of this command.\n   * pass in false for addToUndoStack if this is a command which is NOT\n   * put on the undo stack, like Copy, or a change of selection or Save\n   */\n\n\n  execute() {\n    // Note that this command object must be a NEW command object so it can be\n    // registered to put it onto the stack\n    if (this.addToUndoStack) this.undoHandler.registerExecution(this);\n  }\n  /* override to undo the operation of this command\n   */\n\n\n  undo() {\n    this.isUndo = true;\n    this.undoHandler.reAddShape(this.selectedShapeId); // maybe also need to fix the palette to show this object's color?\n  }\n  /* override to redo the operation of this command, which means to\n   * undo the undo. This should ONLY be called if the immediate\n   * previous operation was an Undo of this command. Anything that\n   * can be undone can be redone, so there is no need for a canRedo.\n   */\n\n\n  redo() {\n    this.isUndo = false;\n    this.undoHandler.unAddShape(this.selectedShapeId); // maybe also need to fix the palette to show this object's color?\n  }\n  /* override to return true if this operation can be repeated in the\n   * current context\n   */\n\n\n  canRepeat() {// return selectedObj !== null;\n  }\n  /* override to execute the operation again, this time possibly on\n   * a new object. Thus, this typically uses the same value but a new\n   * selectedObject.\n   */\n\n\n  repeat() {// if (selectedObj !== null) {\n    //   this.targetObject = selectedObj; // get new selected obj\n    //   this.oldValue = selectedObj.fillColor; // object's current color\n    //   // no change to newValue since reusing the same color\n    //   selectedObj.fillColor = this.newValue; // actually change\n    //   // Note that this command object must be a NEW command object so it can be\n    //   // registered to put it onto the stack\n    //   if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n    // }\n  }\n\n}","map":{"version":3,"sources":["/Users/phoebe0506/github-classroom/CMU-SSUI-Fall2022/hw5-hsuanjuw/src/shared/commandObjects/DeleteCmdObj.js"],"names":["CommandObject","DeleteCmdObj","constructor","undoHandler","newSelectedObj","selectedShapeId","commandName","type","console","log","targetObject","isUndo","selectedObj","execute","addToUndoStack","registerExecution","undo","reAddShape","redo","unAddShape","canRepeat","repeat"],"mappings":"AAAA,OAAOA,aAAP,MAA0B,iBAA1B;AAEA,eAAe,MAAMC,YAAN,SAA2BD,aAA3B,CAAyC;AACtDE,EAAAA,WAAW,CAACC,WAAD,EAAcC,cAAd,EAA8BC,eAA9B,EAA+C;AACxD,UAAMF,WAAN,EAAmB,IAAnB;AACA,SAAKG,WAAL,GAAmB,YAAaF,cAAc,CAACG,IAA/C;AACAC,IAAAA,OAAO,CAACC,GAAR,CAAY,KAAKH,WAAjB;;AACA,QAAIF,cAAc,KAAK,IAAvB,EAA6B;AAC3B,WAAKM,YAAL,GAAoBN,cAApB,CAD2B,CACS;;AACpC,WAAKC,eAAL,GAAuBA,eAAvB;AACA,WAAKM,MAAL,GAAc,KAAd;AACD,KARuD,CASxD;;;AACAC,IAAAA,WAAW,GAAGR,cAAd;AACD;AAED;;;;;;AAIAS,EAAAA,OAAO,GAAG;AACR;AACA;AACA,QAAI,KAAKC,cAAT,EAAyB,KAAKX,WAAL,CAAiBY,iBAAjB,CAAmC,IAAnC;AAC1B;AAED;;;;AAEAC,EAAAA,IAAI,GAAG;AACL,SAAKL,MAAL,GAAc,IAAd;AACA,SAAKR,WAAL,CAAiBc,UAAjB,CAA4B,KAAKZ,eAAjC,EAFK,CAGL;AACD;AAED;;;;;;;AAKAa,EAAAA,IAAI,GAAG;AACL,SAAKP,MAAL,GAAc,KAAd;AACA,SAAKR,WAAL,CAAiBgB,UAAjB,CAA4B,KAAKd,eAAjC,EAFK,CAGL;AACD;AAED;;;;;AAGAe,EAAAA,SAAS,GAAG,CACV;AACD;AAED;;;;;;AAIAC,EAAAA,MAAM,GAAG,CACP;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACD;;AAjEqD","sourcesContent":["import CommandObject from \"./CommandObject\";\n\nexport default class DeleteCmdObj extends CommandObject {\n  constructor(undoHandler, newSelectedObj, selectedShapeId) {\n    super(undoHandler, true);\n    this.commandName = \"Delete \" +  newSelectedObj.type;\n    console.log(this.commandName);\n    if (newSelectedObj !== null) {\n      this.targetObject = newSelectedObj; // global variable for selected\n      this.selectedShapeId = selectedShapeId;\n      this.isUndo = false;\n    }\n    //selectedShapeId = newSelectedShapeId;\n    selectedObj = newSelectedObj;\n  }\n\n  /* override to execute the action of this command.\n   * pass in false for addToUndoStack if this is a command which is NOT\n   * put on the undo stack, like Copy, or a change of selection or Save\n   */\n  execute() {\n    // Note that this command object must be a NEW command object so it can be\n    // registered to put it onto the stack\n    if (this.addToUndoStack) this.undoHandler.registerExecution(this);\n  }\n\n  /* override to undo the operation of this command\n   */\n  undo() {\n    this.isUndo = true;\n    this.undoHandler.reAddShape(this.selectedShapeId);\n    // maybe also need to fix the palette to show this object's color?\n  }\n\n  /* override to redo the operation of this command, which means to\n   * undo the undo. This should ONLY be called if the immediate\n   * previous operation was an Undo of this command. Anything that\n   * can be undone can be redone, so there is no need for a canRedo.\n   */\n  redo() {\n    this.isUndo = false;\n    this.undoHandler.unAddShape(this.selectedShapeId);\n    // maybe also need to fix the palette to show this object's color?\n  }\n\n  /* override to return true if this operation can be repeated in the\n   * current context\n   */\n  canRepeat() {\n    // return selectedObj !== null;\n  }\n\n  /* override to execute the operation again, this time possibly on\n   * a new object. Thus, this typically uses the same value but a new\n   * selectedObject.\n   */\n  repeat() {\n    // if (selectedObj !== null) {\n    //   this.targetObject = selectedObj; // get new selected obj\n    //   this.oldValue = selectedObj.fillColor; // object's current color\n    //   // no change to newValue since reusing the same color\n    //   selectedObj.fillColor = this.newValue; // actually change\n\n    //   // Note that this command object must be a NEW command object so it can be\n    //   // registered to put it onto the stack\n    //   if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n    // }\n  }\n}"]},"metadata":{},"sourceType":"module"}