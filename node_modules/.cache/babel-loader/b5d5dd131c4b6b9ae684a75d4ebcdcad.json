{"ast":null,"code":"import CommandObject from \"./CommandObject\";\nexport default class ChangeBorderColorCommandObject extends CommandObject {\n  constructor(undoHandler, newSelectedObj, newSelectedShapeId, oldWidth, newWidth) {\n    super(undoHandler, true);\n    this.commandName = \"Change \" + newSelectedObj.type + \" border width to \" + newWidth.toString();\n\n    if (newSelectedObj !== null) {\n      this.targetObject = newSelectedObj;\n      this.oldValue = oldWidth;\n      this.newValue = newWidth;\n      this.selectedShapeId = newSelectedShapeId;\n      this.isUndo = false;\n    } //selectedShapeId = newSelectedShapeId;\n    //selectedObj = newSelectedObj;\n\n  }\n  /* override to execute the action of this command.\n   * pass in false for addToUndoStack if this is a command which is NOT\n   * put on the undo stack, like Copy, or a change of selection or Save\n   */\n\n\n  execute() {\n    // Note that this command object must be a NEW command object so it can be\n    // registered to put it onto the stack\n    if (this.addToUndoStack) this.undoHandler.registerExecution(this);\n  }\n  /* override to undo the operation of this command\n   */\n\n\n  undo() {\n    this.isUndo = true;\n    this.undoHandler.updateShape(this.selectedShapeId, {\n      borderWidth: this.oldValue\n    }); // maybe also need to fix the palette to show this object's color?\n\n    let paletteValues = {\n      mode: \"select\",\n      borderColor: this.targetObject.borderColor,\n      borderWidth: this.oldValue,\n      fillColor: this.targetObject.fillColor\n    };\n    this.undoHandler.setPaletteValues(paletteValues);\n  }\n  /* override to redo the operation of this command, which means to\n   * undo the undo. This should ONLY be called if the immediate\n   * previous operation was an Undo of this command. Anything that\n   * can be undone can be redone, so there is no need for a canRedo.\n   */\n\n\n  redo() {\n    this.isUndo = false;\n    this.undoHandler.updateShape(this.selectedShapeId, {\n      borderWidth: this.newValue\n    });\n    let paletteValues = {\n      mode: \"select\",\n      borderColor: this.targetObject.borderColor,\n      borderWidth: this.newValue,\n      fillColor: this.targetObject.fillColor\n    };\n    this.undoHandler.setPaletteValues(paletteValues); // maybe also need to fix the palette to show this object's color?\n  }\n  /* override to return true if this operation can be repeated in the\n   * current context\n   */\n\n\n  canRepeat() {// return selectedObj !== null;\n  }\n  /* override to execute the operation again, this time possibly on\n   * a new object. Thus, this typically uses the same value but a new\n   * selectedObject.\n   */\n\n\n  repeat() {//   if (selectedObj !== null) {\n    //     this.targetObject = selectedObj; // get new selected obj\n    //     this.oldValue = selectedObj.fillColor; // object's current color\n    //     // no change to newValue since reusing the same color\n    //     selectedObj.fillColor = this.newValue; // actually change\n    //     // Note that this command object must be a NEW command object so it can be\n    //     // registered to put it onto the stack\n    //     if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n    //   }\n  }\n\n}","map":{"version":3,"sources":["/Users/phoebe0506/github-classroom/CMU-SSUI-Fall2022/hw5-hsuanjuw/src/shared/commandObjects/ChangeBorderWidthCmdObj.js"],"names":["CommandObject","ChangeBorderColorCommandObject","constructor","undoHandler","newSelectedObj","newSelectedShapeId","oldWidth","newWidth","commandName","type","toString","targetObject","oldValue","newValue","selectedShapeId","isUndo","execute","addToUndoStack","registerExecution","undo","updateShape","borderWidth","paletteValues","mode","borderColor","fillColor","setPaletteValues","redo","canRepeat","repeat"],"mappings":"AAAA,OAAOA,aAAP,MAA0B,iBAA1B;AAEA,eAAe,MAAMC,8BAAN,SAA6CD,aAA7C,CAA2D;AACxEE,EAAAA,WAAW,CAACC,WAAD,EAAcC,cAAd,EAA8BC,kBAA9B,EAAkDC,QAAlD,EAA4DC,QAA5D,EAAsE;AAC/E,UAAMJ,WAAN,EAAmB,IAAnB;AACA,SAAKK,WAAL,GAAmB,YAAaJ,cAAc,CAACK,IAA5B,GAAmC,mBAAnC,GAAyDF,QAAQ,CAACG,QAAT,EAA5E;;AAEA,QAAIN,cAAc,KAAK,IAAvB,EAA6B;AAC3B,WAAKO,YAAL,GAAoBP,cAApB;AACA,WAAKQ,QAAL,GAAgBN,QAAhB;AACA,WAAKO,QAAL,GAAgBN,QAAhB;AACA,WAAKO,eAAL,GAAuBT,kBAAvB;AACA,WAAKU,MAAL,GAAc,KAAd;AACD,KAV8E,CAW/E;AACA;;AACD;AAED;;;;;;AAIAC,EAAAA,OAAO,GAAG;AACR;AACA;AACA,QAAI,KAAKC,cAAT,EAAyB,KAAKd,WAAL,CAAiBe,iBAAjB,CAAmC,IAAnC;AAC1B;AAED;;;;AAEAC,EAAAA,IAAI,GAAG;AACL,SAAKJ,MAAL,GAAc,IAAd;AACA,SAAKZ,WAAL,CAAiBiB,WAAjB,CAA6B,KAAKN,eAAlC,EAAmD;AAACO,MAAAA,WAAW,EAAE,KAAKT;AAAnB,KAAnD,EAFK,CAGL;;AACA,QAAIU,aAAa,GAAG;AAClBC,MAAAA,IAAI,EAAE,QADY;AAElBC,MAAAA,WAAW,EAAE,KAAKb,YAAL,CAAkBa,WAFb;AAGlBH,MAAAA,WAAW,EAAE,KAAKT,QAHA;AAIlBa,MAAAA,SAAS,EAAE,KAAKd,YAAL,CAAkBc;AAJX,KAApB;AAMA,SAAKtB,WAAL,CAAiBuB,gBAAjB,CAAkCJ,aAAlC;AACD;AAED;;;;;;;AAKAK,EAAAA,IAAI,GAAG;AACL,SAAKZ,MAAL,GAAc,KAAd;AACA,SAAKZ,WAAL,CAAiBiB,WAAjB,CAA6B,KAAKN,eAAlC,EAAmD;AAACO,MAAAA,WAAW,EAAE,KAAKR;AAAnB,KAAnD;AACA,QAAIS,aAAa,GAAG;AAClBC,MAAAA,IAAI,EAAE,QADY;AAElBC,MAAAA,WAAW,EAAE,KAAKb,YAAL,CAAkBa,WAFb;AAGlBH,MAAAA,WAAW,EAAE,KAAKR,QAHA;AAIlBY,MAAAA,SAAS,EAAE,KAAKd,YAAL,CAAkBc;AAJX,KAApB;AAMA,SAAKtB,WAAL,CAAiBuB,gBAAjB,CAAkCJ,aAAlC,EATK,CAUL;AACD;AAED;;;;;AAGAM,EAAAA,SAAS,GAAG,CACV;AACD;AAED;;;;;;AAIAC,EAAAA,MAAM,GAAG,CACT;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACC;;AAjFuE","sourcesContent":["import CommandObject from \"./CommandObject\";\n\nexport default class ChangeBorderColorCommandObject extends CommandObject {\n  constructor(undoHandler, newSelectedObj, newSelectedShapeId, oldWidth, newWidth) {\n    super(undoHandler, true);\n    this.commandName = \"Change \" +  newSelectedObj.type + \" border width to \" + newWidth.toString();\n\n    if (newSelectedObj !== null) {\n      this.targetObject = newSelectedObj; \n      this.oldValue = oldWidth; \n      this.newValue = newWidth; \n      this.selectedShapeId = newSelectedShapeId;\n      this.isUndo = false;\n    }\n    //selectedShapeId = newSelectedShapeId;\n    //selectedObj = newSelectedObj;\n  }\n\n  /* override to execute the action of this command.\n   * pass in false for addToUndoStack if this is a command which is NOT\n   * put on the undo stack, like Copy, or a change of selection or Save\n   */\n  execute() {\n    // Note that this command object must be a NEW command object so it can be\n    // registered to put it onto the stack\n    if (this.addToUndoStack) this.undoHandler.registerExecution(this);\n  }\n\n  /* override to undo the operation of this command\n   */\n  undo() {\n    this.isUndo = true;\n    this.undoHandler.updateShape(this.selectedShapeId, {borderWidth: this.oldValue});\n    // maybe also need to fix the palette to show this object's color?\n    let paletteValues = {\n      mode: \"select\",\n      borderColor: this.targetObject.borderColor,\n      borderWidth: this.oldValue,\n      fillColor: this.targetObject.fillColor    \n    };\n    this.undoHandler.setPaletteValues(paletteValues);\n  }\n\n  /* override to redo the operation of this command, which means to\n   * undo the undo. This should ONLY be called if the immediate\n   * previous operation was an Undo of this command. Anything that\n   * can be undone can be redone, so there is no need for a canRedo.\n   */\n  redo() {\n    this.isUndo = false;\n    this.undoHandler.updateShape(this.selectedShapeId, {borderWidth: this.newValue});\n    let paletteValues = {\n      mode: \"select\",\n      borderColor: this.targetObject.borderColor,\n      borderWidth: this.newValue,\n      fillColor: this.targetObject.fillColor    \n    };\n    this.undoHandler.setPaletteValues(paletteValues);\n    // maybe also need to fix the palette to show this object's color?\n  }\n\n  /* override to return true if this operation can be repeated in the\n   * current context\n   */\n  canRepeat() {\n    // return selectedObj !== null;\n  }\n\n  /* override to execute the operation again, this time possibly on\n   * a new object. Thus, this typically uses the same value but a new\n   * selectedObject.\n   */\n  repeat() {\n  //   if (selectedObj !== null) {\n  //     this.targetObject = selectedObj; // get new selected obj\n  //     this.oldValue = selectedObj.fillColor; // object's current color\n  //     // no change to newValue since reusing the same color\n  //     selectedObj.fillColor = this.newValue; // actually change\n\n  //     // Note that this command object must be a NEW command object so it can be\n  //     // registered to put it onto the stack\n  //     if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n  //   }\n  }\n}"]},"metadata":{},"sourceType":"module"}