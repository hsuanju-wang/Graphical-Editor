{"ast":null,"code":"import CommandObject from \"./CommandObject\";\nlet selectedObj;\nexport default class AddShapeCmdObj extends CommandObject {\n  constructor(undoHandler, newSelectedObj, selectedShapeId) {\n    super(undoHandler, true);\n    this.commandName = \"Create \" + newSelectedObj.type;\n    if (newSelectedObj !== null) {\n      this.targetObject = newSelectedObj; // global variable for selected\n      this.selectedShapeId = selectedShapeId;\n      this.isUndo = false;\n    }\n    //selectedShapeId = newSelectedShapeId;\n    selectedObj = newSelectedObj;\n  }\n\n  /* override to execute the action of this command.\n   * pass in false for addToUndoStack if this is a command which is NOT\n   * put on the undo stack, like Copy, or a change of selection or Save\n   */\n  execute() {\n    // Note that this command object must be a NEW command object so it can be\n    // registered to put it onto the stack\n    if (this.addToUndoStack) this.undoHandler.registerExecution(this);\n  }\n\n  /* override to undo the operation of this command\n   */\n  undo() {\n    this.isUndo = true;\n    this.undoHandler.unAddShape(this.selectedShapeId);\n    // maybe also need to fix the palette to show this object's color?\n  }\n\n  /* override to redo the operation of this command, which means to\n   * undo the undo. This should ONLY be called if the immediate\n   * previous operation was an Undo of this command. Anything that\n   * can be undone can be redone, so there is no need for a canRedo.\n   */\n  redo() {\n    this.isUndo = false;\n    this.undoHandler.reAddShape(this.selectedShapeId);\n    // maybe also need to fix the palette to show this object's color?\n  }\n\n  /* override to return true if this operation can be repeated in the\n   * current context\n   */\n  canRepeat() {\n    return selectedObj !== null;\n  }\n\n  /* override to execute the operation again, this time possibly on\n   * a new object. Thus, this typically uses the same value but a new\n   * selectedObject.\n   */\n  repeat() {\n    if (selectedObj !== null) {\n      this.targetObject = selectedObj; // get new selected obj\n      this.oldValue = selectedObj.fillColor; // object's current color\n      // no change to newValue since reusing the same color\n      selectedObj.fillColor = this.newValue; // actually change\n\n      // Note that this command object must be a NEW command object so it can be\n      // registered to put it onto the stack\n      if (this.addToUndoStack) this.undoHandler.registerExecution({\n        ...this\n      });\n    }\n  }\n}","map":{"version":3,"names":["CommandObject","selectedObj","AddShapeCmdObj","constructor","undoHandler","newSelectedObj","selectedShapeId","commandName","type","targetObject","isUndo","execute","addToUndoStack","registerExecution","undo","unAddShape","redo","reAddShape","canRepeat","repeat","oldValue","fillColor","newValue"],"sources":["/Users/phoebe0506/github-classroom/CMU-SSUI-Fall2022/hw5-hsuanjuw/src/shared/commandObjects/AddShapeCmdObj.js"],"sourcesContent":["import CommandObject from \"./CommandObject\";\nlet selectedObj;\n\nexport default class AddShapeCmdObj extends CommandObject {\n  constructor(undoHandler, newSelectedObj, selectedShapeId) {\n    super(undoHandler, true);\n    this.commandName = \"Create \" +  newSelectedObj.type;\n    if (newSelectedObj !== null) {\n      this.targetObject = newSelectedObj; // global variable for selected\n      this.selectedShapeId = selectedShapeId;\n      this.isUndo = false;\n    }\n    //selectedShapeId = newSelectedShapeId;\n    selectedObj = newSelectedObj;\n  }\n\n  /* override to execute the action of this command.\n   * pass in false for addToUndoStack if this is a command which is NOT\n   * put on the undo stack, like Copy, or a change of selection or Save\n   */\n  execute() {\n    // Note that this command object must be a NEW command object so it can be\n    // registered to put it onto the stack\n    if (this.addToUndoStack) this.undoHandler.registerExecution(this);\n  }\n\n  /* override to undo the operation of this command\n   */\n  undo() {\n    this.isUndo = true;\n    this.undoHandler.unAddShape(this.selectedShapeId);\n    // maybe also need to fix the palette to show this object's color?\n  }\n\n  /* override to redo the operation of this command, which means to\n   * undo the undo. This should ONLY be called if the immediate\n   * previous operation was an Undo of this command. Anything that\n   * can be undone can be redone, so there is no need for a canRedo.\n   */\n  redo() {\n    this.isUndo = false;\n    this.undoHandler.reAddShape(this.selectedShapeId);\n    // maybe also need to fix the palette to show this object's color?\n  }\n\n  /* override to return true if this operation can be repeated in the\n   * current context\n   */\n  canRepeat() {\n    return selectedObj !== null;\n  }\n\n  /* override to execute the operation again, this time possibly on\n   * a new object. Thus, this typically uses the same value but a new\n   * selectedObject.\n   */\n  repeat() {\n    if (selectedObj !== null) {\n      this.targetObject = selectedObj; // get new selected obj\n      this.oldValue = selectedObj.fillColor; // object's current color\n      // no change to newValue since reusing the same color\n      selectedObj.fillColor = this.newValue; // actually change\n\n      // Note that this command object must be a NEW command object so it can be\n      // registered to put it onto the stack\n      if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n    }\n  }\n}"],"mappings":"AAAA,OAAOA,aAAa,MAAM,iBAAiB;AAC3C,IAAIC,WAAW;AAEf,eAAe,MAAMC,cAAc,SAASF,aAAa,CAAC;EACxDG,WAAWA,CAACC,WAAW,EAAEC,cAAc,EAAEC,eAAe,EAAE;IACxD,KAAK,CAACF,WAAW,EAAE,IAAI,CAAC;IACxB,IAAI,CAACG,WAAW,GAAG,SAAS,GAAIF,cAAc,CAACG,IAAI;IACnD,IAAIH,cAAc,KAAK,IAAI,EAAE;MAC3B,IAAI,CAACI,YAAY,GAAGJ,cAAc,CAAC,CAAC;MACpC,IAAI,CAACC,eAAe,GAAGA,eAAe;MACtC,IAAI,CAACI,MAAM,GAAG,KAAK;IACrB;IACA;IACAT,WAAW,GAAGI,cAAc;EAC9B;;EAEA;AACF;AACA;AACA;EACEM,OAAOA,CAAA,EAAG;IACR;IACA;IACA,IAAI,IAAI,CAACC,cAAc,EAAE,IAAI,CAACR,WAAW,CAACS,iBAAiB,CAAC,IAAI,CAAC;EACnE;;EAEA;AACF;EACEC,IAAIA,CAAA,EAAG;IACL,IAAI,CAACJ,MAAM,GAAG,IAAI;IAClB,IAAI,CAACN,WAAW,CAACW,UAAU,CAAC,IAAI,CAACT,eAAe,CAAC;IACjD;EACF;;EAEA;AACF;AACA;AACA;AACA;EACEU,IAAIA,CAAA,EAAG;IACL,IAAI,CAACN,MAAM,GAAG,KAAK;IACnB,IAAI,CAACN,WAAW,CAACa,UAAU,CAAC,IAAI,CAACX,eAAe,CAAC;IACjD;EACF;;EAEA;AACF;AACA;EACEY,SAASA,CAAA,EAAG;IACV,OAAOjB,WAAW,KAAK,IAAI;EAC7B;;EAEA;AACF;AACA;AACA;EACEkB,MAAMA,CAAA,EAAG;IACP,IAAIlB,WAAW,KAAK,IAAI,EAAE;MACxB,IAAI,CAACQ,YAAY,GAAGR,WAAW,CAAC,CAAC;MACjC,IAAI,CAACmB,QAAQ,GAAGnB,WAAW,CAACoB,SAAS,CAAC,CAAC;MACvC;MACApB,WAAW,CAACoB,SAAS,GAAG,IAAI,CAACC,QAAQ,CAAC,CAAC;;MAEvC;MACA;MACA,IAAI,IAAI,CAACV,cAAc,EAAE,IAAI,CAACR,WAAW,CAACS,iBAAiB,CAAC;QAAE,GAAG;MAAK,CAAC,CAAC;IAC1E;EACF;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}