{"ast":null,"code":"var _jsxFileName = \"/Users/phoebe0506/github-classroom/CMU-SSUI-Fall2022/hw5-hsuanjuw/src/containers/Workspace/SVGLayer/SVGLayer.js\";\nimport React, { useEffect, useCallback, useContext, useState } from \"react\";\nimport Line from \"./shapes/Line\";\nimport Rect from \"./shapes/Rect\";\nimport Ellipse from \"./shapes/Ellipse\";\nimport ControlContext from \"../../../contexts/control-context\";\nimport { selectShadowId } from \"../../../shared/util\";\n\nconst SVGLayer = () => {\n  const {\n    currMode,\n    currBorderColor,\n    currBorderWidth,\n    currFillColor,\n    shapes,\n    shapesMap,\n    addShape,\n    moveShape,\n    selectedShapeId,\n    selectShape\n  } = useContext(ControlContext); // use useState to set elements in the React state directly\n  // the first element of the list is the state value\n  // the second element of the list is a function to update the state value in the future\n\n  const [drawing, setDrawing] = useState(false);\n  const [initPoint, setInitPoint] = useState({\n    x: undefined,\n    y: undefined\n  });\n  const [currPoint, setCurrPoint] = useState({\n    x: undefined,\n    y: undefined\n  });\n  const [dragging, setDragging] = useState(false);\n  const [draggingShape, setDraggingShape] = useState(undefined);\n  const [draggingShapeOldPos, setDraggingShapeOldPos] = useState({\n    initCoords: {\n      x: undefined,\n      y: undefined\n    },\n    finalCoords: {\n      x: undefined,\n      y: undefined\n    }\n  });\n  const [draggingShapeNewPos, setDraggingShapeNewPos] = useState({\n    initCoords: {\n      x: undefined,\n      y: undefined\n    },\n    finalCoords: {\n      x: undefined,\n      y: undefined\n    }\n  });\n  const [mouseDownPoint, setMouseDownPoint] = useState({\n    x: undefined,\n    y: undefined\n  });\n\n  const handleMouseDown = e => {\n    if (currMode !== \"select\") {\n      // should create\n      setDrawing(true);\n      setInitPoint({\n        x: e.nativeEvent.offsetX,\n        y: e.nativeEvent.offsetY\n      });\n      setCurrPoint({\n        x: e.nativeEvent.offsetX,\n        y: e.nativeEvent.offsetY\n      });\n      e.preventDefault();\n    } else {\n      // should select\n      if (e.target.nodeName === \"svg\") {\n        // deselect\n        selectShape(undefined);\n      } else {\n        // select\n        const targetId = e.target.id;\n        selectShape(targetId);\n        setDragging(true);\n        setMouseDownPoint({\n          x: e.nativeEvent.offsetX,\n          y: e.nativeEvent.offsetY\n        });\n        setDraggingShape(shapesMap[shapes.filter(shapeId => shapeId === targetId)[0]]);\n        setDraggingShapeOldPos({\n          initCoords: {\n            x: shapesMap[shapes.filter(shapeId => shapeId === targetId)[0]].initCoords.x,\n            y: shapesMap[shapes.filter(shapeId => shapeId === targetId)[0]].initCoords.y\n          },\n          finalCoords: {\n            x: shapesMap[shapes.filter(shapeId => shapeId === targetId)[0]].finalCoords.x,\n            y: shapesMap[shapes.filter(shapeId => shapeId === targetId)[0]].finalCoords.y\n          }\n        });\n      }\n    }\n  };\n\n  const handleMouseMove = e => {\n    if (drawing) {\n      setCurrPoint({\n        x: e.nativeEvent.offsetX,\n        y: e.nativeEvent.offsetY\n      });\n    } else if (dragging && draggingShape) {\n      const deltaX = e.nativeEvent.offsetX - mouseDownPoint.x;\n      const deltaY = e.nativeEvent.offsetY - mouseDownPoint.y;\n      moveShape({\n        initCoords: {\n          x: draggingShape.initCoords.x + deltaX,\n          y: draggingShape.initCoords.y + deltaY\n        },\n        finalCoords: {\n          x: draggingShape.finalCoords.x + deltaX,\n          y: draggingShape.finalCoords.y + deltaY\n        }\n      });\n      setDraggingShapeNewPos({\n        initCoords: {\n          x: draggingShape.initCoords.x + deltaX,\n          y: draggingShape.initCoords.y + deltaY\n        },\n        finalCoords: {\n          x: draggingShape.finalCoords.x + deltaX,\n          y: draggingShape.finalCoords.y + deltaY\n        }\n      });\n    }\n  };\n\n  const handleMouseUp = e => {\n    if (currMode !== \"select\") {\n      if (!(initPoint.x === currPoint.x && initPoint.y === currPoint.y)) {\n        // check if it's too small\n        const threshold = 10;\n        let shouldCreate = true;\n        const deltaX = Math.abs(initPoint.x - currPoint.x);\n        const deltaY = Math.abs(initPoint.y - currPoint.y);\n\n        if (currMode === \"line\") {\n          if (Math.sqrt(deltaX ** 2 + deltaY ** 2) < threshold) {\n            shouldCreate = false;\n          }\n        } else {\n          if (deltaX < threshold || deltaY < threshold) {\n            shouldCreate = false;\n          }\n        }\n\n        if (shouldCreate) {\n          // create\n          addShape({\n            type: currMode,\n            visible: true,\n            initCoords: initPoint,\n            finalCoords: currPoint,\n            borderColor: currBorderColor,\n            borderWidth: currBorderWidth,\n            fillColor: currFillColor\n          });\n        }\n      }\n\n      setDrawing(false);\n      setInitPoint({\n        x: undefined,\n        y: undefined\n      });\n      setCurrPoint({\n        x: undefined,\n        y: undefined\n      });\n    } else {\n      setDragging(false);\n      setDraggingShape(undefined);\n      setMouseDownPoint({\n        x: undefined,\n        y: undefined\n      });\n    }\n  }; // useCallback gives a memoized version of the callback that changes when one of its dependencies change\n  // the first argument is the function that will be run\n  // the second is the dependencies that the function relies on\n\n\n  const escKeyDownHandler = useCallback(e => {\n    if (e.key === \"Escape\") {\n      // abort\n      if (drawing) {\n        setDrawing(false);\n        setInitPoint({\n          x: undefined,\n          y: undefined\n        });\n        setCurrPoint({\n          x: undefined,\n          y: undefined\n        });\n      } else if (dragging) {\n        moveShape({\n          initCoords: {\n            x: draggingShape.initCoords.x,\n            y: draggingShape.initCoords.y\n          },\n          finalCoords: {\n            x: draggingShape.finalCoords.x,\n            y: draggingShape.finalCoords.y\n          }\n        });\n        setDragging(false);\n        setDraggingShape(undefined);\n        setMouseDownPoint({\n          x: undefined,\n          y: undefined\n        });\n      }\n    }\n  }, [drawing, dragging, draggingShape, moveShape]); // useEffect will run after the render is committed to the screen\n  // the first argument is the function that will run\n  // the second argument are the dependencies, meaning this will only run when there is a change in these values\n\n  useEffect(() => {\n    window.addEventListener(\"keydown\", escKeyDownHandler, true);\n    return () => window.removeEventListener(\"keydown\", escKeyDownHandler, true);\n  }, [escKeyDownHandler]);\n\n  const genShape = (shapeData, key = undefined) => {\n    const {\n      initCoords,\n      finalCoords,\n      borderColor,\n      borderWidth,\n      fillColor,\n      id\n    } = shapeData;\n    const filter = selectedShapeId && selectedShapeId === id ? `url(#${selectShadowId})` : null;\n\n    switch (shapeData.type) {\n      case \"line\":\n        {\n          return React.createElement(Line, {\n            x1: initCoords.x,\n            y1: initCoords.y,\n            x2: finalCoords.x,\n            y2: finalCoords.y,\n            borderColor,\n            borderWidth,\n            id,\n            key,\n            filter\n          });\n        }\n\n      case \"rect\":\n        {\n          return React.createElement(Rect, {\n            x: Math.min(initCoords.x, finalCoords.x),\n            y: Math.min(initCoords.y, finalCoords.y),\n            width: Math.abs(finalCoords.x - initCoords.x),\n            height: Math.abs(finalCoords.y - initCoords.y),\n            fillColor,\n            borderColor,\n            borderWidth,\n            id,\n            key,\n            filter\n          });\n        }\n\n      case \"ellipse\":\n        {\n          let x = Math.min(finalCoords.x, initCoords.x);\n          let y = Math.min(finalCoords.y, initCoords.y);\n          let w = Math.abs(finalCoords.x - initCoords.x);\n          let h = Math.abs(finalCoords.y - initCoords.y);\n          return React.createElement(Ellipse, {\n            cx: x + w / 2,\n            cy: y + h / 2,\n            rx: w / 2,\n            ry: h / 2,\n            fillColor,\n            borderColor,\n            borderWidth,\n            id,\n            key,\n            filter\n          });\n        }\n\n      default:\n        {\n          return null;\n        }\n    }\n  };\n\n  const renderShape = (shapeData, key) => {\n    if (shapeData.visible) {\n      return genShape(shapeData, key);\n    } else {\n      return null;\n    }\n  };\n\n  const renderTempShape = () => {\n    if (initPoint.x !== undefined && initPoint.y !== undefined && currPoint.x !== undefined && currPoint.y !== undefined) {\n      return genShape({\n        type: currMode,\n        initCoords: initPoint,\n        finalCoords: currPoint,\n        borderColor: currBorderColor,\n        borderWidth: currBorderWidth,\n        fillColor: currFillColor\n      });\n    }\n  };\n\n  return /*#__PURE__*/React.createElement(\"svg\", {\n    id: \"workspace-svg\",\n    width: \"800\",\n    height: \"700\",\n    onMouseDown: handleMouseDown,\n    onMouseMove: handleMouseMove,\n    onMouseUp: handleMouseUp,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 301,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"filter\", {\n    id: selectShadowId,\n    x: \"-100%\",\n    y: \"-100%\",\n    width: \"400%\",\n    height: \"400%\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 309,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"feDropShadow\", {\n    dx: \"0\",\n    dy: \"0\",\n    stdDeviation: \"15\",\n    floodColor: \"rgba(0, 0, 0, 0.7)\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 316,\n      columnNumber: 9\n    }\n  })), shapes.map((shapeId, idx) => {\n    return renderShape(shapesMap[shapeId], idx);\n  }), drawing && renderTempShape());\n};\n\nexport default SVGLayer;","map":{"version":3,"sources":["/Users/phoebe0506/github-classroom/CMU-SSUI-Fall2022/hw5-hsuanjuw/src/containers/Workspace/SVGLayer/SVGLayer.js"],"names":["React","useEffect","useCallback","useContext","useState","Line","Rect","Ellipse","ControlContext","selectShadowId","SVGLayer","currMode","currBorderColor","currBorderWidth","currFillColor","shapes","shapesMap","addShape","moveShape","selectedShapeId","selectShape","drawing","setDrawing","initPoint","setInitPoint","x","undefined","y","currPoint","setCurrPoint","dragging","setDragging","draggingShape","setDraggingShape","draggingShapeOldPos","setDraggingShapeOldPos","initCoords","finalCoords","draggingShapeNewPos","setDraggingShapeNewPos","mouseDownPoint","setMouseDownPoint","handleMouseDown","e","nativeEvent","offsetX","offsetY","preventDefault","target","nodeName","targetId","id","filter","shapeId","handleMouseMove","deltaX","deltaY","handleMouseUp","threshold","shouldCreate","Math","abs","sqrt","type","visible","borderColor","borderWidth","fillColor","escKeyDownHandler","key","window","addEventListener","removeEventListener","genShape","shapeData","createElement","x1","y1","x2","y2","min","width","height","w","h","cx","cy","rx","ry","renderShape","renderTempShape","map","idx"],"mappings":"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","sourcesContent":["import React, { useEffect, useCallback, useContext, useState } from \"react\";\n\nimport Line from \"./shapes/Line\";\nimport Rect from \"./shapes/Rect\";\nimport Ellipse from \"./shapes/Ellipse\";\n\nimport ControlContext from \"../../../contexts/control-context\";\nimport { selectShadowId } from \"../../../shared/util\";\n\nconst SVGLayer = () => {\n  const {\n    currMode,\n    currBorderColor,\n    currBorderWidth,\n    currFillColor,\n    shapes,\n    shapesMap,\n    addShape,\n    moveShape,\n    selectedShapeId,\n    selectShape,\n  } = useContext(ControlContext);\n\n  // use useState to set elements in the React state directly\n  // the first element of the list is the state value\n  // the second element of the list is a function to update the state value in the future\n  const [drawing, setDrawing] = useState(false);\n  const [initPoint, setInitPoint] = useState({ x: undefined, y: undefined });\n  const [currPoint, setCurrPoint] = useState({ x: undefined, y: undefined });\n\n  const [dragging, setDragging] = useState(false);\n  const [draggingShape, setDraggingShape] = useState(undefined);\n  const [draggingShapeOldPos, setDraggingShapeOldPos] = useState({\n    initCoords: {\n      x: undefined,\n      y: undefined,\n    },\n    finalCoords: {\n      x: undefined,\n      y: undefined,\n    }    \n  });\n  const [draggingShapeNewPos, setDraggingShapeNewPos] = useState({\n    initCoords: {\n      x: undefined,\n      y: undefined,\n    },\n    finalCoords: {\n      x: undefined,\n      y: undefined,\n    }    \n  });\n  const [mouseDownPoint, setMouseDownPoint] = useState({\n    x: undefined,\n    y: undefined,\n  });\n\n  const handleMouseDown = (e) => {\n    if (currMode !== \"select\") {\n      // should create\n      setDrawing(true);\n      setInitPoint({ x: e.nativeEvent.offsetX, y: e.nativeEvent.offsetY });\n      setCurrPoint({ x: e.nativeEvent.offsetX, y: e.nativeEvent.offsetY });\n      e.preventDefault();\n    } else {\n      // should select\n      if (e.target.nodeName === \"svg\") {\n        // deselect\n        selectShape(undefined);\n      } else {\n        // select\n        const targetId = e.target.id;\n        selectShape(targetId);\n        setDragging(true);\n        setMouseDownPoint({\n          x: e.nativeEvent.offsetX,\n          y: e.nativeEvent.offsetY,\n        });\n        setDraggingShape(\n          shapesMap[shapes.filter((shapeId) => shapeId === targetId)[0]]\n        );\n        setDraggingShapeOldPos({\n          initCoords: {\n            x: shapesMap[shapes.filter((shapeId) => shapeId === targetId)[0]].initCoords.x,\n            y: shapesMap[shapes.filter((shapeId) => shapeId === targetId)[0]].initCoords.y,\n          },\n          finalCoords: {\n            x: shapesMap[shapes.filter((shapeId) => shapeId === targetId)[0]].finalCoords.x,\n            y: shapesMap[shapes.filter((shapeId) => shapeId === targetId)[0]].finalCoords.y,\n          }\n        });\n      }\n    }\n  };\n\n  const handleMouseMove = (e) => {\n    if (drawing) {\n      setCurrPoint({ x: e.nativeEvent.offsetX, y: e.nativeEvent.offsetY });\n    } else if (dragging && draggingShape) {\n      const deltaX = e.nativeEvent.offsetX - mouseDownPoint.x;\n      const deltaY = e.nativeEvent.offsetY - mouseDownPoint.y;\n\n      moveShape({\n        initCoords: {\n          x: draggingShape.initCoords.x + deltaX,\n          y: draggingShape.initCoords.y + deltaY,\n        },\n        finalCoords: {\n          x: draggingShape.finalCoords.x + deltaX,\n          y: draggingShape.finalCoords.y + deltaY,\n        },\n      });\n      setDraggingShapeNewPos({\n        initCoords: {\n          x: draggingShape.initCoords.x + deltaX,\n          y: draggingShape.initCoords.y + deltaY,\n        },\n        finalCoords: {\n          x: draggingShape.finalCoords.x + deltaX,\n          y: draggingShape.finalCoords.y + deltaY,\n        },\n      });\n    }\n  };\n\n  const handleMouseUp = (e) => {\n    if (currMode !== \"select\") {\n      if (!(initPoint.x === currPoint.x && initPoint.y === currPoint.y)) {\n        // check if it's too small\n        const threshold = 10;\n        let shouldCreate = true;\n        const deltaX = Math.abs(initPoint.x - currPoint.x);\n        const deltaY = Math.abs(initPoint.y - currPoint.y);\n        if (currMode === \"line\") {\n          if (Math.sqrt(deltaX ** 2 + deltaY ** 2) < threshold) {\n            shouldCreate = false;\n          }\n        } else {\n          if (deltaX < threshold || deltaY < threshold) {\n            shouldCreate = false;\n          }\n        }\n\n        if (shouldCreate) {\n          // create\n          addShape({\n            type: currMode,\n            visible: true,\n            initCoords: initPoint,\n            finalCoords: currPoint,\n            borderColor: currBorderColor,\n            borderWidth: currBorderWidth,\n            fillColor: currFillColor,\n          });\n        }\n      }\n\n      setDrawing(false);\n      setInitPoint({ x: undefined, y: undefined });\n      setCurrPoint({ x: undefined, y: undefined });\n    } else {\n\n      setDragging(false);\n      setDraggingShape(undefined);\n      setMouseDownPoint({ x: undefined, y: undefined });\n    }\n  };\n\n  // useCallback gives a memoized version of the callback that changes when one of its dependencies change\n  // the first argument is the function that will be run\n  // the second is the dependencies that the function relies on\n  const escKeyDownHandler = useCallback(\n    (e) => {\n      if (e.key === \"Escape\") {\n        // abort\n        if (drawing) {\n          setDrawing(false);\n          setInitPoint({ x: undefined, y: undefined });\n          setCurrPoint({ x: undefined, y: undefined });\n        } else if (dragging) {\n          moveShape({\n            initCoords: {\n              x: draggingShape.initCoords.x,\n              y: draggingShape.initCoords.y,\n            },\n            finalCoords: {\n              x: draggingShape.finalCoords.x,\n              y: draggingShape.finalCoords.y,\n            },\n          });\n          setDragging(false);\n          setDraggingShape(undefined);\n          setMouseDownPoint({ x: undefined, y: undefined });\n        }\n      }\n    },\n    [drawing, dragging, draggingShape, moveShape]\n  );\n\n  // useEffect will run after the render is committed to the screen\n  // the first argument is the function that will run\n  // the second argument are the dependencies, meaning this will only run when there is a change in these values\n  useEffect(() => {\n    window.addEventListener(\"keydown\", escKeyDownHandler, true);\n    return () => window.removeEventListener(\"keydown\", escKeyDownHandler, true);\n  }, [escKeyDownHandler]);\n\n  const genShape = (shapeData, key = undefined) => {\n    const {\n      initCoords,\n      finalCoords,\n      borderColor,\n      borderWidth,\n      fillColor,\n      id,\n    } = shapeData;\n    const filter =\n      selectedShapeId && selectedShapeId === id\n        ? `url(#${selectShadowId})`\n        : null;\n    switch (shapeData.type) {\n      case \"line\": {\n        return React.createElement(Line, {\n          x1: initCoords.x,\n          y1: initCoords.y,\n          x2: finalCoords.x,\n          y2: finalCoords.y,\n          borderColor,\n          borderWidth,\n          id,\n          key,\n          filter,\n        });\n      }\n      case \"rect\": {\n        return React.createElement(Rect, {\n          x: Math.min(initCoords.x, finalCoords.x),\n          y: Math.min(initCoords.y, finalCoords.y),\n          width: Math.abs(finalCoords.x - initCoords.x),\n          height: Math.abs(finalCoords.y - initCoords.y),\n          fillColor,\n          borderColor,\n          borderWidth,\n          id,\n          key,\n          filter,\n        });\n      }\n      case \"ellipse\": {\n        let x = Math.min(finalCoords.x, initCoords.x);\n        let y = Math.min(finalCoords.y, initCoords.y);\n        let w = Math.abs(finalCoords.x - initCoords.x);\n        let h = Math.abs(finalCoords.y - initCoords.y);\n\n        return React.createElement(Ellipse, {\n          cx: x + w / 2,\n          cy: y + h / 2,\n          rx: w / 2,\n          ry: h / 2,\n          fillColor,\n          borderColor,\n          borderWidth,\n          id,\n          key,\n          filter,\n        });\n      }\n      default: {\n        return null;\n      }\n    }\n  };\n\n  const renderShape = (shapeData, key) => {\n    if (shapeData.visible) {\n      return genShape(shapeData, key);\n    } else {\n      return null;\n    }\n  };\n\n  const renderTempShape = () => {\n    if (\n      initPoint.x !== undefined &&\n      initPoint.y !== undefined &&\n      currPoint.x !== undefined &&\n      currPoint.y !== undefined\n    ) {\n      return genShape({\n        type: currMode,\n        initCoords: initPoint,\n        finalCoords: currPoint,\n        borderColor: currBorderColor,\n        borderWidth: currBorderWidth,\n        fillColor: currFillColor,\n      });\n    }\n  };\n\n  return (\n    <svg\n      id=\"workspace-svg\"\n      width=\"800\"\n      height=\"700\"\n      onMouseDown={handleMouseDown}\n      onMouseMove={handleMouseMove}\n      onMouseUp={handleMouseUp}\n    >\n      <filter\n        id={selectShadowId}\n        x=\"-100%\"\n        y=\"-100%\"\n        width=\"400%\"\n        height=\"400%\"\n      >\n        <feDropShadow\n          dx=\"0\"\n          dy=\"0\"\n          stdDeviation=\"15\"\n          floodColor=\"rgba(0, 0, 0, 0.7)\"\n        />\n      </filter>\n      {shapes.map((shapeId, idx) => {\n        return renderShape(shapesMap[shapeId], idx);\n      })}\n      {drawing && renderTempShape()}\n    </svg>\n  );\n};\n\nexport default SVGLayer;\n"]},"metadata":{},"sourceType":"module"}