{"ast":null,"code":"import CommandObject from \"./CommandObject\";\nlet selectedObj;\nlet fillColorWidget;\nexport default class ChangeFillColorCommandObject extends CommandObject {\n  constructor(undoHandler, selectedObj, fillColorWidget) {\n    super(undoHandler, true);\n    this.targetObject = newSelectedObj;\n    this.oldValue = selectedObj.fillColor;\n    this.targetObject = selectedObj; // global variable for selected\n\n    this.oldValue = selectedObj.fillColor; // object's current color\n\n    this.newValue = fillColorWidget.currentColor; // get the color widget's current color\n\n    selectedObj.fillColor = this.newValue; // actually change\n  }\n  /* override to execute the action of this command.\n   * pass in false for addToUndoStack if this is a command which is NOT\n   * put on the undo stack, like Copy, or a change of selection or Save\n   */\n\n\n  execute() {}\n  /* override to undo the operation of this command\n   */\n\n\n  undo() {\n    this.targetObject.fillColor = this.oldValue; // maybe also need to fix the palette to show this object's color?\n  }\n  /* override to redo the operation of this command, which means to\n   * undo the undo. This should ONLY be called if the immediate\n   * previous operation was an Undo of this command. Anything that\n   * can be undone can be redone, so there is no need for a canRedo.\n   */\n\n\n  redo() {\n    this.targetObject.fillColor = this.newValue; // maybe also need to fix the palette to show this object's color?\n  }\n  /* override to return true if this operation can be repeated in the\n   * current context\n   */\n\n\n  canRepeat() {\n    return selectedObj !== null;\n  }\n  /* override to execute the operation again, this time possibly on\n   * a new object. Thus, this typically uses the same value but a new\n   * selectedObject.\n   */\n\n\n  repeat() {\n    if (selectedObj !== null) {\n      this.targetObject = selectedObj; // get new selected obj\n\n      this.oldValue = selectedObj.fillColor; // object's current color\n      // no change to newValue since reusing the same color\n\n      selectedObj.fillColor = this.newValue; // actually change\n      // Note that this command object must be a NEW command object so it can be\n      // registered to put it onto the stack\n\n      if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this\n      });\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/phoebe0506/github-classroom/CMU-SSUI-Fall2022/hw5-hsuanjuw/src/shared/commandObjects/ChangeFillColorCommandObject.js"],"names":["CommandObject","selectedObj","fillColorWidget","ChangeFillColorCommandObject","constructor","undoHandler","targetObject","newSelectedObj","oldValue","fillColor","newValue","currentColor","execute","undo","redo","canRepeat","repeat","addToUndoStack","registerExecution"],"mappings":"AAAA,OAAOA,aAAP,MAA0B,iBAA1B;AACA,IAAIC,WAAJ;AACA,IAAIC,eAAJ;AAEA,eAAe,MAAMC,4BAAN,SAA2CH,aAA3C,CAAyD;AACtEI,EAAAA,WAAW,CAACC,WAAD,EAAcJ,WAAd,EAA2BC,eAA3B,EAA4C;AACrD,UAAMG,WAAN,EAAmB,IAAnB;AACA,SAAKC,YAAL,GAAoBC,cAApB;AACA,SAAKC,QAAL,GAAgBP,WAAW,CAACQ,SAA5B;AACA,SAAKH,YAAL,GAAoBL,WAApB,CAJqD,CAIpB;;AACjC,SAAKO,QAAL,GAAgBP,WAAW,CAACQ,SAA5B,CALqD,CAKd;;AACvC,SAAKC,QAAL,GAAgBR,eAAe,CAACS,YAAhC,CANqD,CAMP;;AAC9CV,IAAAA,WAAW,CAACQ,SAAZ,GAAwB,KAAKC,QAA7B,CAPqD,CAOd;AACxC;AAED;;;;;;AAIAE,EAAAA,OAAO,GAAG,CAET;AAED;;;;AAEAC,EAAAA,IAAI,GAAG;AACL,SAAKP,YAAL,CAAkBG,SAAlB,GAA8B,KAAKD,QAAnC,CADK,CAEL;AACD;AAED;;;;;;;AAKAM,EAAAA,IAAI,GAAG;AACL,SAAKR,YAAL,CAAkBG,SAAlB,GAA8B,KAAKC,QAAnC,CADK,CAEL;AACD;AAED;;;;;AAGAK,EAAAA,SAAS,GAAG;AACV,WAAOd,WAAW,KAAK,IAAvB;AACD;AAED;;;;;;AAIAe,EAAAA,MAAM,GAAG;AACP,QAAIf,WAAW,KAAK,IAApB,EAA0B;AACxB,WAAKK,YAAL,GAAoBL,WAApB,CADwB,CACS;;AACjC,WAAKO,QAAL,GAAgBP,WAAW,CAACQ,SAA5B,CAFwB,CAEe;AACvC;;AACAR,MAAAA,WAAW,CAACQ,SAAZ,GAAwB,KAAKC,QAA7B,CAJwB,CAIe;AAEvC;AACA;;AACA,UAAI,KAAKO,cAAT,EAAyB,KAAKZ,WAAL,CAAiBa,iBAAjB,CAAmC,EAAE,GAAG;AAAL,OAAnC;AAC1B;AACF;;AA1DqE","sourcesContent":["import CommandObject from \"./CommandObject\";\nlet selectedObj;\nlet fillColorWidget;\n\nexport default class ChangeFillColorCommandObject extends CommandObject {\n  constructor(undoHandler, selectedObj, fillColorWidget) {\n    super(undoHandler, true);\n    this.targetObject = newSelectedObj;\n    this.oldValue = selectedObj.fillColor;\n    this.targetObject = selectedObj; // global variable for selected\n    this.oldValue = selectedObj.fillColor; // object's current color\n    this.newValue = fillColorWidget.currentColor; // get the color widget's current color\n    selectedObj.fillColor = this.newValue; // actually change\n  }\n\n  /* override to execute the action of this command.\n   * pass in false for addToUndoStack if this is a command which is NOT\n   * put on the undo stack, like Copy, or a change of selection or Save\n   */\n  execute() {\n\n  }\n\n  /* override to undo the operation of this command\n   */\n  undo() {\n    this.targetObject.fillColor = this.oldValue;\n    // maybe also need to fix the palette to show this object's color?\n  }\n\n  /* override to redo the operation of this command, which means to\n   * undo the undo. This should ONLY be called if the immediate\n   * previous operation was an Undo of this command. Anything that\n   * can be undone can be redone, so there is no need for a canRedo.\n   */\n  redo() {\n    this.targetObject.fillColor = this.newValue;\n    // maybe also need to fix the palette to show this object's color?\n  }\n\n  /* override to return true if this operation can be repeated in the\n   * current context\n   */\n  canRepeat() {\n    return selectedObj !== null;\n  }\n\n  /* override to execute the operation again, this time possibly on\n   * a new object. Thus, this typically uses the same value but a new\n   * selectedObject.\n   */\n  repeat() {\n    if (selectedObj !== null) {\n      this.targetObject = selectedObj; // get new selected obj\n      this.oldValue = selectedObj.fillColor; // object's current color\n      // no change to newValue since reusing the same color\n      selectedObj.fillColor = this.newValue; // actually change\n\n      // Note that this command object must be a NEW command object so it can be\n      // registered to put it onto the stack\n      if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}