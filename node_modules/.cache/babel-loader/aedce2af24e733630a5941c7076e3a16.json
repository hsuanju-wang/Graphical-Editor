{"ast":null,"code":"import CommandObject from \"./CommandObject\";\nlet selectedObj; //let selectedShapeId;\n\nexport default class ChangeFillColorCommandObject extends CommandObject {\n  constructor(undoHandler, newSelectedObj, newSelectedShapeId, oldColor, newFillColor) {\n    super(undoHandler, true);\n    this.commandName = \"Change \" + newSelectedObj.type + \" color to \" + newFillColor.toString();\n    console.log(this.commandName);\n\n    if (newSelectedObj !== null) {\n      this.targetObject = newSelectedObj; // global variable for selected\n\n      this.oldValue = oldColor; // object's current color\n\n      this.newValue = newFillColor; // get the color widget's current color\n\n      this.selectedShapeId = newSelectedShapeId;\n      this.isUndo = false;\n    } //selectedShapeId = newSelectedShapeId;\n\n\n    selectedObj = newSelectedObj;\n  }\n  /* override to execute the action of this command.\n   * pass in false for addToUndoStack if this is a command which is NOT\n   * put on the undo stack, like Copy, or a change of selection or Save\n   */\n\n\n  execute() {\n    // Note that this command object must be a NEW command object so it can be\n    // registered to put it onto the stack\n    if (this.addToUndoStack) this.undoHandler.registerExecution(this);\n  }\n  /* override to undo the operation of this command\n   */\n\n\n  undo() {\n    this.setState({\n      isUndo: true\n    });\n    this.undoHandler.updateShape(this.selectedShapeId, {\n      fillColor: this.oldValue\n    }); // maybe also need to fix the palette to show this object's color?\n  }\n  /* override to redo the operation of this command, which means to\n   * undo the undo. This should ONLY be called if the immediate\n   * previous operation was an Undo of this command. Anything that\n   * can be undone can be redone, so there is no need for a canRedo.\n   */\n\n\n  redo() {\n    this.targetObject.fillColor = this.newValue; // maybe also need to fix the palette to show this object's color?\n  }\n  /* override to return true if this operation can be repeated in the\n   * current context\n   */\n\n\n  canRepeat() {\n    return selectedObj !== null;\n  }\n  /* override to execute the operation again, this time possibly on\n   * a new object. Thus, this typically uses the same value but a new\n   * selectedObject.\n   */\n\n\n  repeat() {\n    if (selectedObj !== null) {\n      this.targetObject = selectedObj; // get new selected obj\n\n      this.oldValue = selectedObj.fillColor; // object's current color\n      // no change to newValue since reusing the same color\n\n      selectedObj.fillColor = this.newValue; // actually change\n      // Note that this command object must be a NEW command object so it can be\n      // registered to put it onto the stack\n\n      if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this\n      });\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/phoebe0506/github-classroom/CMU-SSUI-Fall2022/hw5-hsuanjuw/src/shared/commandObjects/ChangeFillColorCommandObject.js"],"names":["CommandObject","selectedObj","ChangeFillColorCommandObject","constructor","undoHandler","newSelectedObj","newSelectedShapeId","oldColor","newFillColor","commandName","type","toString","console","log","targetObject","oldValue","newValue","selectedShapeId","isUndo","execute","addToUndoStack","registerExecution","undo","setState","updateShape","fillColor","redo","canRepeat","repeat"],"mappings":"AAAA,OAAOA,aAAP,MAA0B,iBAA1B;AACA,IAAIC,WAAJ,C,CACA;;AAEA,eAAe,MAAMC,4BAAN,SAA2CF,aAA3C,CAAyD;AACtEG,EAAAA,WAAW,CAACC,WAAD,EAAcC,cAAd,EAA8BC,kBAA9B,EAAkDC,QAAlD,EAA4DC,YAA5D,EAA0E;AACnF,UAAMJ,WAAN,EAAmB,IAAnB;AACA,SAAKK,WAAL,GAAmB,YAAaJ,cAAc,CAACK,IAA5B,GAAmC,YAAnC,GAAkDF,YAAY,CAACG,QAAb,EAArE;AACAC,IAAAA,OAAO,CAACC,GAAR,CAAY,KAAKJ,WAAjB;;AACA,QAAIJ,cAAc,KAAK,IAAvB,EAA6B;AAC3B,WAAKS,YAAL,GAAoBT,cAApB,CAD2B,CACS;;AACpC,WAAKU,QAAL,GAAgBR,QAAhB,CAF2B,CAED;;AAC1B,WAAKS,QAAL,GAAgBR,YAAhB,CAH2B,CAGG;;AAC9B,WAAKS,eAAL,GAAuBX,kBAAvB;AACA,WAAKY,MAAL,GAAc,KAAd;AACD,KAVkF,CAWnF;;;AACAjB,IAAAA,WAAW,GAAGI,cAAd;AACD;AAED;;;;;;AAIAc,EAAAA,OAAO,GAAG;AACR;AACA;AACA,QAAI,KAAKC,cAAT,EAAyB,KAAKhB,WAAL,CAAiBiB,iBAAjB,CAAmC,IAAnC;AAC1B;AAED;;;;AAEAC,EAAAA,IAAI,GAAG;AACL,SAAKC,QAAL,CAAc;AAACL,MAAAA,MAAM,EAAE;AAAT,KAAd;AACA,SAAKd,WAAL,CAAiBoB,WAAjB,CAA6B,KAAKP,eAAlC,EAAmD;AAACQ,MAAAA,SAAS,EAAE,KAAKV;AAAjB,KAAnD,EAFK,CAGL;AACD;AAED;;;;;;;AAKAW,EAAAA,IAAI,GAAG;AACL,SAAKZ,YAAL,CAAkBW,SAAlB,GAA8B,KAAKT,QAAnC,CADK,CAEL;AACD;AAED;;;;;AAGAW,EAAAA,SAAS,GAAG;AACV,WAAO1B,WAAW,KAAK,IAAvB;AACD;AAED;;;;;;AAIA2B,EAAAA,MAAM,GAAG;AACP,QAAI3B,WAAW,KAAK,IAApB,EAA0B;AACxB,WAAKa,YAAL,GAAoBb,WAApB,CADwB,CACS;;AACjC,WAAKc,QAAL,GAAgBd,WAAW,CAACwB,SAA5B,CAFwB,CAEe;AACvC;;AACAxB,MAAAA,WAAW,CAACwB,SAAZ,GAAwB,KAAKT,QAA7B,CAJwB,CAIe;AAEvC;AACA;;AACA,UAAI,KAAKI,cAAT,EAAyB,KAAKhB,WAAL,CAAiBiB,iBAAjB,CAAmC,EAAE,GAAG;AAAL,OAAnC;AAC1B;AACF;;AAlEqE","sourcesContent":["import CommandObject from \"./CommandObject\";\nlet selectedObj;\n//let selectedShapeId;\n\nexport default class ChangeFillColorCommandObject extends CommandObject {\n  constructor(undoHandler, newSelectedObj, newSelectedShapeId, oldColor, newFillColor) {\n    super(undoHandler, true);\n    this.commandName = \"Change \" +  newSelectedObj.type + \" color to \" + newFillColor.toString();\n    console.log(this.commandName);\n    if (newSelectedObj !== null) {\n      this.targetObject = newSelectedObj; // global variable for selected\n      this.oldValue = oldColor; // object's current color\n      this.newValue = newFillColor; // get the color widget's current color\n      this.selectedShapeId = newSelectedShapeId;\n      this.isUndo = false;\n    }\n    //selectedShapeId = newSelectedShapeId;\n    selectedObj = newSelectedObj;\n  }\n\n  /* override to execute the action of this command.\n   * pass in false for addToUndoStack if this is a command which is NOT\n   * put on the undo stack, like Copy, or a change of selection or Save\n   */\n  execute() {\n    // Note that this command object must be a NEW command object so it can be\n    // registered to put it onto the stack\n    if (this.addToUndoStack) this.undoHandler.registerExecution(this);\n  }\n\n  /* override to undo the operation of this command\n   */\n  undo() {\n    this.setState({isUndo: true});\n    this.undoHandler.updateShape(this.selectedShapeId, {fillColor: this.oldValue});\n    // maybe also need to fix the palette to show this object's color?\n  }\n\n  /* override to redo the operation of this command, which means to\n   * undo the undo. This should ONLY be called if the immediate\n   * previous operation was an Undo of this command. Anything that\n   * can be undone can be redone, so there is no need for a canRedo.\n   */\n  redo() {\n    this.targetObject.fillColor = this.newValue;\n    // maybe also need to fix the palette to show this object's color?\n  }\n\n  /* override to return true if this operation can be repeated in the\n   * current context\n   */\n  canRepeat() {\n    return selectedObj !== null;\n  }\n\n  /* override to execute the operation again, this time possibly on\n   * a new object. Thus, this typically uses the same value but a new\n   * selectedObject.\n   */\n  repeat() {\n    if (selectedObj !== null) {\n      this.targetObject = selectedObj; // get new selected obj\n      this.oldValue = selectedObj.fillColor; // object's current color\n      // no change to newValue since reusing the same color\n      selectedObj.fillColor = this.newValue; // actually change\n\n      // Note that this command object must be a NEW command object so it can be\n      // registered to put it onto the stack\n      if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}