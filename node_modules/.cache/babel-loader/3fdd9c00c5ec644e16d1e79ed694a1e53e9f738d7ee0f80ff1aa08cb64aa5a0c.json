{"ast":null,"code":"import CommandObject from \"./CommandObject\";\n//let selectedObj;\n//let selectedShapeId;\n\nexport default class ChangeFillColorCommandObject extends CommandObject {\n  constructor(undoHandler, newSelectedObj, newSelectedShapeId, oldColor, newFillColor) {\n    super(undoHandler, true);\n    this.commandName = \"Change \" + newSelectedObj.type + \" fill color to \" + newFillColor.toString();\n    if (newSelectedObj !== null) {\n      this.targetObject = newSelectedObj;\n      this.oldValue = oldColor; // object's current color\n      this.newValue = newFillColor;\n      this.selectedShapeId = newSelectedShapeId;\n      this.isUndo = false;\n    }\n    //selectedShapeId = newSelectedShapeId;\n    //selectedObj = newSelectedObj;\n  }\n\n  /* override to execute the action of this command.\n   * pass in false for addToUndoStack if this is a command which is NOT\n   * put on the undo stack, like Copy, or a change of selection or Save\n   */\n  execute() {\n    // Note that this command object must be a NEW command object so it can be\n    // registered to put it onto the stack\n    if (this.addToUndoStack) this.undoHandler.registerExecution(this);\n  }\n\n  /* override to undo the operation of this command\n   */\n  undo() {\n    this.isUndo = true;\n    this.undoHandler.updateShape(this.selectedShapeId, {\n      fillColor: this.oldValue\n    });\n    // maybe also need to fix the palette to show this object's color?\n    let paletteValues = {\n      mode: \"select\",\n      borderColor: this.targetObject.borderColor,\n      borderWidth: this.targetObject.borderWidth,\n      fillColor: this.oldValue\n    };\n    this.undoHandler.setPaletteValues(paletteValues);\n  }\n\n  /* override to redo the operation of this command, which means to\n   * undo the undo. This should ONLY be called if the immediate\n   * previous operation was an Undo of this command. Anything that\n   * can be undone can be redone, so there is no need for a canRedo.\n   */\n  redo() {\n    this.isUndo = false;\n    this.undoHandler.updateShape(this.selectedShapeId, {\n      fillColor: this.newValue\n    });\n    let paletteValues = {\n      mode: \"select\",\n      borderColor: this.targetObject.borderColor,\n      borderWidth: this.targetObject.borderWidth,\n      fillColor: this.newValue\n    };\n    this.undoHandler.setPaletteValues(paletteValues);\n    // maybe also need to fix the palette to show this object's color?\n  }\n\n  /* override to return true if this operation can be repeated in the\n   * current context\n   */\n  canRepeat() {\n    // return selectedObj !== null;\n  }\n\n  /* override to execute the operation again, this time possibly on\n   * a new object. Thus, this typically uses the same value but a new\n   * selectedObject.\n   */\n  repeat() {\n    //   if (selectedObj !== null) {\n    //     this.targetObject = selectedObj; // get new selected obj\n    //     this.oldValue = selectedObj.fillColor; // object's current color\n    //     // no change to newValue since reusing the same color\n    //     selectedObj.fillColor = this.newValue; // actually change\n\n    //     // Note that this command object must be a NEW command object so it can be\n    //     // registered to put it onto the stack\n    //     if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n    //   }\n  }\n}","map":{"version":3,"names":["CommandObject","ChangeFillColorCommandObject","constructor","undoHandler","newSelectedObj","newSelectedShapeId","oldColor","newFillColor","commandName","type","toString","targetObject","oldValue","newValue","selectedShapeId","isUndo","execute","addToUndoStack","registerExecution","undo","updateShape","fillColor","paletteValues","mode","borderColor","borderWidth","setPaletteValues","redo","canRepeat","repeat"],"sources":["/Users/phoebe0506/github-classroom/CMU-SSUI-Fall2022/hw5-hsuanjuw/src/shared/commandObjects/ChangeFillColorCommandObject.js"],"sourcesContent":["import CommandObject from \"./CommandObject\";\n//let selectedObj;\n//let selectedShapeId;\n\nexport default class ChangeFillColorCommandObject extends CommandObject {\n  constructor(undoHandler, newSelectedObj, newSelectedShapeId, oldColor, newFillColor) {\n    super(undoHandler, true);\n    this.commandName = \"Change \" +  newSelectedObj.type + \" fill color to \" + newFillColor.toString();\n    \n    if (newSelectedObj !== null) {\n      this.targetObject = newSelectedObj; \n      this.oldValue = oldColor; // object's current color\n      this.newValue = newFillColor; \n      this.selectedShapeId = newSelectedShapeId;\n      this.isUndo = false;\n    }\n    //selectedShapeId = newSelectedShapeId;\n    //selectedObj = newSelectedObj;\n  }\n\n  /* override to execute the action of this command.\n   * pass in false for addToUndoStack if this is a command which is NOT\n   * put on the undo stack, like Copy, or a change of selection or Save\n   */\n  execute() {\n    // Note that this command object must be a NEW command object so it can be\n    // registered to put it onto the stack\n    if (this.addToUndoStack) this.undoHandler.registerExecution(this);\n  }\n\n  /* override to undo the operation of this command\n   */\n  undo() {\n    this.isUndo = true;\n    this.undoHandler.updateShape(this.selectedShapeId, {fillColor: this.oldValue});\n    // maybe also need to fix the palette to show this object's color?\n    let paletteValues = {\n      mode: \"select\",\n      borderColor: this.targetObject.borderColor,\n      borderWidth: this.targetObject.borderWidth,\n      fillColor: this.oldValue    \n    };\n    this.undoHandler.setPaletteValues(paletteValues);\n  }\n\n  /* override to redo the operation of this command, which means to\n   * undo the undo. This should ONLY be called if the immediate\n   * previous operation was an Undo of this command. Anything that\n   * can be undone can be redone, so there is no need for a canRedo.\n   */\n  redo() {\n    this.isUndo = false;\n    this.undoHandler.updateShape(this.selectedShapeId, {fillColor: this.newValue});\n    let paletteValues = {\n      mode: \"select\",\n      borderColor: this.targetObject.borderColor,\n      borderWidth: this.targetObject.borderWidth,\n      fillColor: this.newValue    \n    };\n    this.undoHandler.setPaletteValues(paletteValues);\n    // maybe also need to fix the palette to show this object's color?\n  }\n\n  /* override to return true if this operation can be repeated in the\n   * current context\n   */\n  canRepeat() {\n    // return selectedObj !== null;\n  }\n\n  /* override to execute the operation again, this time possibly on\n   * a new object. Thus, this typically uses the same value but a new\n   * selectedObject.\n   */\n  repeat() {\n  //   if (selectedObj !== null) {\n  //     this.targetObject = selectedObj; // get new selected obj\n  //     this.oldValue = selectedObj.fillColor; // object's current color\n  //     // no change to newValue since reusing the same color\n  //     selectedObj.fillColor = this.newValue; // actually change\n\n  //     // Note that this command object must be a NEW command object so it can be\n  //     // registered to put it onto the stack\n  //     if (this.addToUndoStack) this.undoHandler.registerExecution({ ...this });\n  //   }\n  }\n}\n"],"mappings":"AAAA,OAAOA,aAAa,MAAM,iBAAiB;AAC3C;AACA;;AAEA,eAAe,MAAMC,4BAA4B,SAASD,aAAa,CAAC;EACtEE,WAAWA,CAACC,WAAW,EAAEC,cAAc,EAAEC,kBAAkB,EAAEC,QAAQ,EAAEC,YAAY,EAAE;IACnF,KAAK,CAACJ,WAAW,EAAE,IAAI,CAAC;IACxB,IAAI,CAACK,WAAW,GAAG,SAAS,GAAIJ,cAAc,CAACK,IAAI,GAAG,iBAAiB,GAAGF,YAAY,CAACG,QAAQ,EAAE;IAEjG,IAAIN,cAAc,KAAK,IAAI,EAAE;MAC3B,IAAI,CAACO,YAAY,GAAGP,cAAc;MAClC,IAAI,CAACQ,QAAQ,GAAGN,QAAQ,CAAC,CAAC;MAC1B,IAAI,CAACO,QAAQ,GAAGN,YAAY;MAC5B,IAAI,CAACO,eAAe,GAAGT,kBAAkB;MACzC,IAAI,CAACU,MAAM,GAAG,KAAK;IACrB;IACA;IACA;EACF;;EAEA;AACF;AACA;AACA;EACEC,OAAOA,CAAA,EAAG;IACR;IACA;IACA,IAAI,IAAI,CAACC,cAAc,EAAE,IAAI,CAACd,WAAW,CAACe,iBAAiB,CAAC,IAAI,CAAC;EACnE;;EAEA;AACF;EACEC,IAAIA,CAAA,EAAG;IACL,IAAI,CAACJ,MAAM,GAAG,IAAI;IAClB,IAAI,CAACZ,WAAW,CAACiB,WAAW,CAAC,IAAI,CAACN,eAAe,EAAE;MAACO,SAAS,EAAE,IAAI,CAACT;IAAQ,CAAC,CAAC;IAC9E;IACA,IAAIU,aAAa,GAAG;MAClBC,IAAI,EAAE,QAAQ;MACdC,WAAW,EAAE,IAAI,CAACb,YAAY,CAACa,WAAW;MAC1CC,WAAW,EAAE,IAAI,CAACd,YAAY,CAACc,WAAW;MAC1CJ,SAAS,EAAE,IAAI,CAACT;IAClB,CAAC;IACD,IAAI,CAACT,WAAW,CAACuB,gBAAgB,CAACJ,aAAa,CAAC;EAClD;;EAEA;AACF;AACA;AACA;AACA;EACEK,IAAIA,CAAA,EAAG;IACL,IAAI,CAACZ,MAAM,GAAG,KAAK;IACnB,IAAI,CAACZ,WAAW,CAACiB,WAAW,CAAC,IAAI,CAACN,eAAe,EAAE;MAACO,SAAS,EAAE,IAAI,CAACR;IAAQ,CAAC,CAAC;IAC9E,IAAIS,aAAa,GAAG;MAClBC,IAAI,EAAE,QAAQ;MACdC,WAAW,EAAE,IAAI,CAACb,YAAY,CAACa,WAAW;MAC1CC,WAAW,EAAE,IAAI,CAACd,YAAY,CAACc,WAAW;MAC1CJ,SAAS,EAAE,IAAI,CAACR;IAClB,CAAC;IACD,IAAI,CAACV,WAAW,CAACuB,gBAAgB,CAACJ,aAAa,CAAC;IAChD;EACF;;EAEA;AACF;AACA;EACEM,SAASA,CAAA,EAAG;IACV;EAAA;;EAGF;AACF;AACA;AACA;EACEC,MAAMA,CAAA,EAAG;IACT;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;EAAA;AAEF"},"metadata":{},"sourceType":"module","externalDependencies":[]}